package com.apistats.lift.record //import net.liftweb.mongodb.record.field.MongoJsonObjectListField
import com.apistatsmodel.messages.APIStatsMessage
import com.foursquare.rogue.Rogue._
import com.foursquare.rogue.LatLong
import java.util.Locale
import net.liftweb.mongodb.record.field._
import net.liftweb.mongodb.record.{MongoId, MongoMetaRecord, MongoRecord}
import net.liftweb.mongodb.JsonObject
import net.liftweb.record.field._
import org.joda.time.DateTime
import scala.collection.mutable.LinkedHashMap
import java.text.DecimalFormat
class APIStatsMessageDoc private () extends MongoRecord[APIStatsMessageDoc] with MongoId[APIStatsMessageDoc] {

  def meta = APIStatsMessageDoc

  object apiName extends StringField(this, 100)

  object contextPath extends StringField(this, 20)

  object resourceURL extends StringField(this, 255)
  object pathParams extends BsonRecordListField[APIStatsMessageDoc, APIParam](this, APIParam)  
  object queryParams extends BsonRecordListField[APIStatsMessageDoc, APIParam](this, APIParam)

  object date extends DateField(this)

  object responseTime extends LongField(this);    object isGeospatialAPI extends BooleanField(this);    object exceptionMessage extends StringField(this, 255);    object hasFailed extends BooleanField(this);    object geolatlng extends MongoCaseClassField[APIStatsMessageDoc, LatLong](this){override def name = "latlng"} 
};

object APIStatsMessageDoc extends APIStatsMessageDoc with MongoMetaRecord[APIStatsMessageDoc] {    def saveMessage(message: APIStatsMessage):Unit = {    val queryParams = message.queryParams.toMap;    val pathParams = message.pathParams.toMap;    val queryParamsLinkedHashMap = LinkedHashMap(queryParams.toSeq:_*);    val pathParamsLinkedHashMap = LinkedHashMap(pathParams.toSeq:_*);    var listQueryParam:List[APIParam] = List[APIParam]();    var listPathParam:List[APIParam] = List[APIParam]();    queryParamsLinkedHashMap.foreach(x => {      val queryParam = APIParam.createRecord.key(x._1.toString).value(x._2.toString);      listQueryParam ++= List(queryParam)    });    pathParamsLinkedHashMap.foreach(x => {      val pathParam = APIParam.createRecord.key(x._1.toString).value(x._2.toString);      listPathParam ++= List(pathParam)    });    val record = APIStatsMessageDoc.createRecord;    if (message.isGeospatial == true){      val latitudeQueryParam = listQueryParam.filter(x => x.key.toString == "latitude");      val longitudeQueryParam = listQueryParam.filter(x => x.key.toString == "longitude");      val latitude = latitudeQueryParam.iterator.next.value.toString.toDouble;      val longitude = longitudeQueryParam.iterator.next.value.toString.toDouble;      val latlng = LatLong(latitude, longitude);      record.geolatlng(latlng)    };    record.apiName(message.apiName)      .contextPath(message.contextPath)      .resourceURL(message.resourceURL)      .pathParams(listPathParam)      .queryParams(listQueryParam)      .date(message.date.toCalendar(new Locale("en-US")).getTime)      .responseTime(message.reponseTime)      .hasFailed(message.hasFailed)      .exceptionMessage(message.exceptionMessage)      .isGeospatialAPI(message.isGeospatial)      .save;  };    def numberOfTotalMessages():Long ={    val numOfMessages = APIStatsMessageDoc count();    numOfMessages.toString.toLong  };        def numberOMessagesByAPIName(apiName:String):Long = {   val numOfMessages = APIStatsMessageDoc where (_.apiName eqs apiName) count();   numOfMessages.toString.toLong  };    def numberOfTotalGeospatialMessages():Long = {    val numOfMessages = APIStatsMessageDoc where ( _.isGeospatialAPI eqs true ) count ();    numOfMessages.toString.toLong  };    def percentageGeospatialMessages():Double = {    formatPercentage((numberOfTotalGeospatialMessages.toDouble / numberOfTotalMessages.toDouble) * 100);  };    def numberOfTotalGeospatialMessagesByAPIName(apiName:String):Long = {    val numOfMessages = APIStatsMessageDoc where ( _.isGeospatialAPI eqs true) and (_.apiName eqs apiName) count ();    numOfMessages.toString.toLong  };    def percentageGeospatialMessagesByAPIName(apiName:String):Double = {   formatPercentage((numberOfTotalGeospatialMessagesByAPIName(apiName).toDouble / numberOMessagesByAPIName(apiName).toDouble) * 100);  };    def messagesFailed():Long = {    val numOfMesasgesFailed = APIStatsMessageDoc where (_.hasFailed eqs true) count();    numOfMesasgesFailed.toString.toLong;  };    def percentageFailed():Double = {    formatPercentage((messagesFailed.toDouble / numberOfTotalMessages) * 100);  };    def messagesFailedByAPIName(apiName:String):Long = {    val numOfMesasgesFailed = APIStatsMessageDoc where (_.hasFailed eqs true) and (_.apiName eqs apiName) count();    numOfMesasgesFailed.toString.toLong;  };    def percentageFailedByAPIName(apiName:String):Double = {    formatPercentage((messagesFailedByAPIName(apiName).toDouble / numberOMessagesByAPIName(apiName)) * 100);  };    def avgResponseTimeLas1000Messages(apiName:String):Double = {    val list = fetch100Messages(apiName);    val avgResponse:Double = list.foldLeft(0L)(_ + _.responseTime._1).toDouble / list.length.toDouble;    formatDouble(avgResponse);  };        def maxResponseTimeLas1000Messages(apiName:String):Long = {    val list = fetch100Messages(apiName);    val maxResponse = list.foldLeft(0L)(_ max _.responseTime._1);    maxResponse;  };              def minResponseTimeLas1000Messages(apiName:String):Long = {    val list = fetch100Messages(apiName);    val minResponse = list.foldLeft(100000L)(_ min _.responseTime._1);    minResponse;  };      private def fetch100Messages(apiName:String):List[APIStatsMessageDoc] = {    if (apiName.equalsIgnoreCase("")){      val list:List[APIStatsMessageDoc] = APIStatsMessageDoc fetch(1000);      list;    }else{      val list:List[APIStatsMessageDoc] = APIStatsMessageDoc where (_.apiName eqs apiName)fetch(1000);      list;    };  };    private def formatPercentage(perc:Double):Double = {    if (perc > 0.000){      val df = new DecimalFormat("#0.000");      val percentage = df.format(perc).toDouble;      if (percentage < 100.00){        percentage      }else{        100.000      }    }else {      0.000    }  };    private def formatDouble(d:Double):Double = {    val df = new DecimalFormat("#0.000");    df.format(d).toDouble;  };    private def max (a:Long, b:Long):Long = { if (a>=b) return a ; return b};    private def min (a:Long, b:Long):Long = { if (a<=b) return a ; return b}}

